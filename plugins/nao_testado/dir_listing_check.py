# plugins/dir_listing_check.py
"""
Plugin: dir_listing_check
Objetivo:
  - Detectar se a listagem de diretórios (autoindex) está habilitada em paths do alvo.
  - Retorna dois itens por path:
      * uuid-006-dir-listing         -> 'Listagem de diretórios habilitada' (detecção)
      * uuid-027-dir-listing-off     -> 'Listagem de diretórios desabilitada' (boa prática)
Config (opcional): configs/dir_listing_check.json
{
  "paths": ["/", "/test/", "/public/"],
  "timeout": 20,
  "max_bytes": 200_000
}
"""

import re
import time
import shlex
import subprocess
from typing import Optional, List, Dict

PLUGIN_CONFIG_NAME = "dir_listing_check"
PLUGIN_CONFIG_ALIASES = ["dirlisting", "autoindex", "listagem_diretorios"]

UUID_ENABLED  = "uuid-006-dir-listing"     # "Listagem de diretórios habilitada"
UUID_DISABLED = "uuid-027-dir-listing-off" # "Listagem de diretórios desabilitada"

DEFAULT_PATHS   = ["/"]
DEFAULT_TIMEOUT = 20
DEFAULT_MAXB    = 200_000

# Padrões clássicos de autoindex
AUTOIDX_PATTERNS = [
    r"(?i)\bIndex of\b",
    r"(?i)\bDirectory listing\b",
    r"(?i)\bParent Directory\b",
    r"(?i)Generated by (?:(?:Apache)|(?:nginx))",
    r"(?i)\bApache Server at\b",
    r"(?i)\bnginx\b.*\bautoindex\b",
]

# Heurística simples para capturar "arquivos" exibidos
# Busca por links <a href="nome"> ou linhas com sufixos conhecidos
FILE_GUESS_PAT = r'(?i)href="([^"]+)"|^\s*[-\w\.\~%/]+\.(?:txt|log|zip|tar|gz|7z|bak|old|php|asp|aspx|js|map|css|conf|ini|env)\s*$'

def _curl_fetch(url: str, timeout: int, max_bytes: int) -> str:
    """
    Baixa conteúdo com curl (seguindo redirecionamentos).
    -k para aceitar self-signed em lab; ajuste se quiser restrito.
    """
    cmd = f"curl -sSL -k --max-time {int(timeout)} {shlex.quote(url)}"
    try:
        p = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout+5)
        data = (p.stdout or "")[:max_bytes]
        # Em algumas páginas, cabeçalhos úteis podem vir com -i. Mantemos simples (body) para heurística.
        return data
    except Exception as e:
        return f"[ERRO curl] {e}"

def _looks_like_autoindex(html: str) -> bool:
    if not html or html.startswith("[ERRO"):
        return False
    for pat in AUTOIDX_PATTERNS:
        if re.search(pat, html):
            return True
    # fallback adicional: presença de listagem típica com <title>Index of /
    if re.search(r'(?i)<title>\s*Index of', html):
        return True
    return False

def _extract_sample_files(html: str, limit: int = 10) -> List[str]:
    if not html or html.startswith("[ERRO"):
        return []
    found = []
    for m in re.finditer(FILE_GUESS_PAT, html, flags=re.M):
        # pegar o grupo do href se existir, senão a linha inteira
        val = m.group(1) if m.group(1) else m.group(0).strip()
        if not val:
            continue
        # ignorar navegadores típicos de parent dir
        if val in ("/", "../"):
            continue
        found.append(val)
        if len(found) >= limit:
            break
    # remover duplicados mantendo ordem
    seen = set()
    out = []
    for x in found:
        if x not in seen:
            seen.add(x)
            out.append(x)
    return out

def _join_url(base: str, path: str) -> str:
    if not base.endswith("/"):
        base = base + "/"
    if path.startswith("/"):
        path = path[1:]
    return base + path

def run_plugin(target: str, ai_fn, cfg: Optional[Dict] = None) -> Dict:
    """
    Assinatura esperada pelo main:
      - target: URL base (ex.: http://host)
      - ai_fn: callable(target, plugin_name, item_uuid, result_text) -> str (no seu main: analyze_item(TARGET,...))
      - cfg: dict opcional com:
          * paths: lista de paths a verificar
          * timeout: segundos curl
          * max_bytes: bytes máximos para ler
    Retorno:
      {
        "plugin": "dir_listing_check",
        "result": [ {scan_item_uuid, result, analysis_ai, severity, duration, auto}, ... ]
      }
    """
    plugin_name = "dir_listing_check"
    cfg = cfg or {}
    paths   = cfg.get("paths", DEFAULT_PATHS) or DEFAULT_PATHS
    timeout = int(cfg.get("timeout", DEFAULT_TIMEOUT))
    maxb    = int(cfg.get("max_bytes", DEFAULT_MAXB))

    results = []

    for p in paths:
        url = target if p in ("", "/") else _join_url(target, p)
        t0 = time.time()
        html = _curl_fetch(url, timeout=timeout, max_bytes=maxb)
        dt = time.time() - t0

        is_auto = _looks_like_autoindex(html)
        files   = _extract_sample_files(html)

        if is_auto:
            # Item 1: HABILITADA (falha)
            text1 = f"Listagem de diretórios habilitada em {url}"
            if files:
                text1 += f" | Amostra: {', '.join(files[:5])}"
            analysis1 = ai_fn(plugin_name, UUID_ENABLED, text1) if callable(ai_fn) else None
            results.append({
                "scan_item_uuid": UUID_ENABLED,
                "result": text1,
                "analysis_ai": analysis1,
                "severity": "medium",  # pode aumentar para 'high' se evidências sensíveis
                "duration": dt,
                "auto": True
            })
            # Item 2: DESABILITADA (boa prática) -> como a listagem está habilitada, isso é uma 'falha' da boa prática
            text2 = f"Boa prática não atendida em {url}: listagem de diretórios deveria estar desabilitada."
            analysis2 = ai_fn(plugin_name, UUID_DISABLED, text2) if callable(ai_fn) else None
            results.append({
                "scan_item_uuid": UUID_DISABLED,
                "result": text2,
                "analysis_ai": analysis2,
                "severity": "medium",
                "duration": dt,
                "auto": True
            })
        else:
            # Item 1: HABILITADA -> não detectado (info)
            text1 = f"Nenhum padrão de autoindex detectado em {url}"
            analysis1 = ai_fn(plugin_name, UUID_ENABLED, text1) if callable(ai_fn) else None
            results.append({
                "scan_item_uuid": UUID_ENABLED,
                "result": text1,
                "analysis_ai": analysis1,
                "severity": "info",
                "duration": dt,
                "auto": True
            })
            # Item 2: DESABILITADA (boa prática) -> atendida
            text2 = f"Listagem de diretórios parece desabilitada em {url} (boa prática)."
            analysis2 = ai_fn(plugin_name, UUID_DISABLED, text2) if callable(ai_fn) else None
            results.append({
                "scan_item_uuid": UUID_DISABLED,
                "result": text2,
                "analysis_ai": analysis2,
                "severity": "info",
                "duration": dt,
                "auto": True
            })

    return {
        "plugin": "dir_listing_check",
        "result": results
    }
