# plugins/dir_listing_check.py
"""
Plugin: dir_listing_check
Objetivo:
  - Detectar se a listagem de diretórios (autoindex) está habilitada em paths do alvo.
  - Gera resultado apenas quando a listagem estiver habilitada.
Config (opcional): configs/dir_listing_check.json
{
  "paths": ["/", "/test/", "/public/"],
  "timeout": 20,
  "max_bytes": 200_000
}
"""

import re
import time
import subprocess
from typing import Optional, List, Dict, Any

PLUGIN_CONFIG_NAME = "dir_listing_check"
PLUGIN_CONFIG_ALIASES = ["dirlisting", "autoindex", "listagem_diretorios"]

UUID_ENABLED  = "uuid-006-dir-listing"     # "Listagem de diretórios habilitada"

DEFAULT_PATHS   = ["/"]
DEFAULT_TIMEOUT = 20
DEFAULT_MAXB    = 200_000

AUTOIDX_PATTERNS = [
    r"(?i)\bIndex of\b",
    r"(?i)\bDirectory listing\b",
    r"(?i)\bParent Directory\b",
    r"(?i)Generated by (?:(?:Apache)|(?:nginx))",
    r"(?i)\bApache Server at\b",
    r"(?i)\bnginx\b.*\bautoindex\b",
]

FILE_GUESS_PAT = r'(?i)href="([^"]+)"|^\s*[-\w\.\~%/]+\.(?:txt|log|zip|tar|gz|7z|bak|old|php|asp|aspx|js|map|css|conf|ini|env)\s*$'

# === injected: capture executed shell commands for tagging ===
try:
    from utils import run_cmd as __run_cmd_orig
except Exception:
    __run_cmd_orig = None

EXEC_CMDS: List[str] = []

def run_cmd(cmd, timeout=None):
    """
    Wrapper para capturar o comando exato usado (preenchendo EXEC_CMDS).
    """
    cmd_str = " ".join(cmd) if isinstance(cmd, (list, tuple)) else str(cmd)
    EXEC_CMDS.append(cmd_str)
    if __run_cmd_orig is None:
        try:
            p = subprocess.run(cmd, shell=isinstance(cmd, str), capture_output=True, text=True, timeout=(timeout or 30))
            return (p.stdout or "") + (p.stderr or "")
        except Exception as e:
            return f"[ERRO run_cmd-fallback] {e}"
    return __run_cmd_orig(cmd, timeout=timeout)
# === end injected ===

def _looks_like_autoindex(html: str) -> bool:
    if not html or html.startswith("[ERRO"):
        return False
    for pat in AUTOIDX_PATTERNS:
        if re.search(pat, html):
            return True
    if re.search(r'(?i)<title>\s*Index of', html):
        return True
    return False

def _extract_sample_files(html: str, limit: int = 10) -> List[str]:
    if not html or html.startswith("[ERRO"):
        return []
    found = []
    for m in re.finditer(FILE_GUESS_PAT, html, flags=re.M):
        val = m.group(1) if m.group(1) else m.group(0).strip()
        if not val:
            continue
        if val in ("/", "../"):
            continue
        found.append(val)
        if len(found) >= limit:
            break
    seen = set()
    out = []
    for x in found:
        if x not in seen:
            seen.add(x)
            out.append(x)
    return out

def _join_url(base: str, path: str) -> str:
    if not base.endswith("/"):
        base = base + "/"
    if path.startswith("/"):
        path = path[1:]
    return base + path

def _curl_fetch(url: str, timeout: int, max_bytes: int) -> str:
    """
    Baixa conteúdo com curl (seguindo redirecionamentos).
    Usa run_cmd para registrar o comando.
    """
    cmd = ["curl", "-sSL", "-k", "--max-time", str(int(timeout)), url]
    try:
        out = run_cmd(cmd, timeout=timeout + 5)
        data = (out or "")[:max_bytes]
        return data
    except Exception as e:
        return f"[ERRO curl] {e}"

def build_item(uuid: str, msg: str, severity: str, duration: float, ai_fn, item_name: str) -> Dict[str, Any]:
    return {
        "scan_item_uuid": uuid,
        "result": msg,
        "analysis_ai": ai_fn(PLUGIN_CONFIG_NAME, uuid, msg) if callable(ai_fn) else None,
        "severity": severity,
        "duration": duration,
        "auto": True,
        "item_name": item_name,
        "command": EXEC_CMDS[-1] if EXEC_CMDS else "",
    }

def run_plugin(target: str, ai_fn, cfg: Optional[Dict] = None) -> Dict[str, Any]:
    """
    Retorna resultados APENAS quando detecta listagem de diretórios habilitada.
    Caso contrário, result: [].
    """
    plugin_name = PLUGIN_CONFIG_NAME
    cfg = cfg or {}
    paths   = cfg.get("paths", DEFAULT_PATHS) or DEFAULT_PATHS
    timeout = int(cfg.get("timeout", DEFAULT_TIMEOUT))
    maxb    = int(cfg.get("max_bytes", DEFAULT_MAXB))

    results = []
    for p in paths:
        url = target if p in ("", "/") else _join_url(target, p)
        t0 = time.time()
        html = _curl_fetch(url, timeout=timeout, max_bytes=maxb)
        dt = time.time() - t0

        if _looks_like_autoindex(html):
            files = _extract_sample_files(html)
            text = f"Listagem de diretórios habilitada em {url}"
            if files:
                text += f" | Amostra: {', '.join(files[:5])}"
            results.append(build_item(UUID_ENABLED, text, "medium", dt, ai_fn, f"Dir listing at {url}"))
        # se não detectado, NÃO produzir item algum

    return {
        "plugin": plugin_name,
        "file_name": "dir_listing_check.py",
        "description": "Detecta presença de listagem de diretórios (autoindex). Gera item apenas quando presente.",
        "category": "Information Gathering",
        "result": results
    }
